// Generated by CoffeeScript 1.10.0
(function() {
  var checkToken, circleciHost, clearAllProjectsCache, clearProjectCache, endpoint, formatBuildStatus, getProjectsByStatus, handleResponse, listProjectsByStatus, querystring, retryBuild, retryProjectsByStatus, toDisplay, toProject, toSha, url, util;

  url = require('url');

  util = require('util');

  querystring = require('querystring');

  circleciHost = process.env.HUBOT_CIRCLECI_HOST? process.env.HUBOT_CIRCLECI_HOST : "circleci.com";

  endpoint = "https://" + circleciHost + "/api/v1";

  toProject = function(project) {
    if (project.indexOf("/") === -1 && (process.env.HUBOT_GITHUB_ORG != null)) {
      return process.env.HUBOT_GITHUB_ORG + "/" + project;
    } else {
      return project;
    }
  };

  toSha = function(vcs_revision) {
    return vcs_revision.substring(0, 7);
  };

  toDisplay = function(status) {
    return status[0].toUpperCase() + status.slice(1);
  };

  formatBuildStatus = function(build) {
    return (toDisplay(build.status)) + " in build " + build.build_num + " of " + build.vcs_url + " [" + build.branch + "/" + (toSha(build.vcs_revision)) + "] " + build.committer_name + ": " + build.subject + " - " + build.why;
  };

  retryBuild = function(msg, endpoint, project, build_num) {
    return msg.http(endpoint + "/project/" + project + "/" + build_num + "/retry?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
      "Accept": "application/json"
    }).post('{}')(handleResponse(msg, function(response) {
      return msg.send("Retrying build " + build_num + " of " + project + " [" + response.branch + "] with build " + response.build_num);
    }));
  };

  getProjectsByStatus = function(msg, endpoint, status, action) {
    var projects;
    projects = [];
    return msg.http(endpoint + "/projects?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
      "Accept": "application/json"
    }).get()(handleResponse(msg, function(response) {
      var build_branch, i, last_build, len, project;
      for (i = 0, len = response.length; i < len; i++) {
        project = response[i];
        build_branch = project.branches[project.default_branch];
        last_build = build_branch.recent_builds[0];
        if (last_build.outcome === status) {
          projects.push(project);
        }
      }
      if (action === 'list') {
        return listProjectsByStatus(msg, projects, status);
      } else if (action === 'retry') {
        return retryProjectsByStatus(msg, projects, status);
      }
    }));
  };

  retryProjectsByStatus = function(msg, projects, status) {
    var build_branch, i, last_build, len, project, results;
    results = [];
    for (i = 0, len = projects.length; i < len; i++) {
      project = projects[i];
      build_branch = project.branches[project.default_branch];
      last_build = build_branch.recent_builds[0];
      project = toProject(project.reponame);
      results.push(retryBuild(msg, endpoint, project, last_build.build_num));
    }
    return results;
  };

  listProjectsByStatus = function(msg, projects, status) {
    var build_branch, i, last_build, len, message, project;
    if (projects.length === 0) {
      return msg.send("No projects match status " + status);
    } else {
      message = "Projects where the last build's status is " + status + ":\n";
      for (i = 0, len = projects.length; i < len; i++) {
        project = projects[i];
        build_branch = project.branches[project.default_branch];
        last_build = build_branch.recent_builds[0];
        message = message + ((toDisplay(last_build.outcome)) + " in build https://circleci.com/gh/" + project.username + "/" + project.reponame + "/" + last_build.build_num + " of " + project.vcs_url + " [" + project.default_branch + "]\n");
      }
      return msg.send("" + message);
    }
  };

  clearProjectCache = function(msg, endpoint, project) {
    return msg.http(endpoint + "/project/" + project + "/build-cache?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
      "Accept": "application/json"
    }).del('{}')(handleResponse(msg, function(response) {
      return msg.send("Cleared build cache for " + project);
    }));
  };

  clearAllProjectsCache = function(msg, endpoint) {
    return msg.http(endpoint + "/projects?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
      "Accept": "application/json"
    }).get()(handleResponse(msg, function(response) {
      var i, len, project, projectname, results;
      results = [];
      for (i = 0, len = response.length; i < len; i++) {
        project = response[i];
        projectname = escape(toProject(project.reponame));
        results.push(clearProjectCache(msg, endpoint, projectname));
      }
      return results;
    }));
  };

  checkToken = function(msg) {
    if (process.env.HUBOT_CIRCLECI_TOKEN == null) {
      msg.send('You need to set HUBOT_CIRCLECI_TOKEN to a valid CircleCI API token');
      return false;
    } else {
      return true;
    }
  };

  handleResponse = function(msg, handler) {
    return function(err, res, body) {
      var response;
      if (err != null) {
        msg.send("Something went really wrong: " + err);
      }
      switch (res.statusCode) {
        case 404:
          response = JSON.parse(body);
          return msg.send("I couldn't find what you were looking for: " + response.message);
        case 401:
          return msg.send('Not authorized.  Did you set HUBOT_CIRCLECI_TOKEN correctly?');
        case 500:
          return msg.send('Yikes!  I turned that circle into a square');
        case 200:
          response = JSON.parse(body);
          return handler(response);
        default:
          return msg.send("Hmm.  I don't know how to process that CircleCI response: " + res.statusCode, body);
      }
    };
  };

  module.exports = function(robot) {
    robot.respond(/circle me (\S*)\s*(\S*)/i, function(msg) {
      var branch, project;
      if (!checkToken(msg)) {
        return;
      }
      project = escape(toProject(msg.match[1]));
      branch = msg.match[2] ? escape(msg.match[2]) : 'master';
      return msg.http(endpoint + "/project/" + project + "/tree/" + branch + "?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
        "Accept": "application/json"
      }).get()(handleResponse(msg, function(response) {
        var currentBuild;
        if (response.length === 0) {
          return msg.send("Current status: " + project + " [" + branch + "]: unknown");
        } else {
          currentBuild = response[0];
          return msg.send("Current status: " + (formatBuildStatus(currentBuild)));
        }
      }));
    });
    robot.respond(/circle last (\S*)\s*(\S*)/i, function(msg) {
      var branch, project;
      if (!checkToken(msg)) {
        return;
      }
      project = escape(toProject(msg.match[1]));
      branch = msg.match[2] ? escape(msg.match[2]) : 'master';
      return msg.http(endpoint + "/project/" + project + "/tree/" + branch + "?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
        "Accept": "application/json"
      }).get()(handleResponse(msg, function(response) {
        var last;
        if (response.length === 0) {
          return msg.send("Current status: " + project + " [" + branch + "]: unknown");
        } else {
          last = response[0];
          if (last.status !== 'running') {
            return msg.send("Current status: " + (formatBuildStatus(last)));
          } else if (last.previous && last.previous.status) {
            return msg.send("Last status: " + (formatBuildStatus(last)));
          } else {
            return msg.send("Last build status for " + project + " [" + branch + "]: unknown");
          }
        }
      }));
    });
    robot.respond(/circle retry (.*) (.*)/i, function(msg) {
      var branch, build_num, project, status;
      if (!checkToken(msg)) {
        return;
      }
      if (msg.match[1] === 'all') {
        status = escape(msg.match[2]);
        getProjectsByStatus(msg, endpoint, status, 'retry');
        return;
      } else {
        project = escape(toProject(msg.match[1]));
      }
      build_num = escape(msg.match[2]);
      if (build_num === 'last') {
        branch = 'master';
        return msg.http(endpoint + "/project/" + project + "/tree/" + branch + "?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
          "Accept": "application/json"
        }).get()(handleResponse(msg, function(response) {
          var last;
          last = response[0];
          build_num = last.build_num;
          return retryBuild(msg, endpoint, project, build_num);
        }));
      } else {
        return retryBuild(msg, endpoint, project, build_num);
      }
    });
    robot.respond(/circle list (.*)/i, function(msg) {
      var status;
      if (!checkToken(msg)) {
        return;
      }
      status = escape(msg.match[1]);
      if (status !== 'failed' && status !== 'success') {
        msg.send("Status can only be failed or success.");
        return;
      }
      return getProjectsByStatus(msg, endpoint, status, 'list');
    });
    robot.respond(/circle cancel (.*) (.*)/i, function(msg) {
      var build_num, project;
      if (!checkToken(msg)) {
        return;
      }
      project = escape(toProject(msg.match[1]));
      if (msg.match[2] == null) {
        msg.send("I can't cancel without a build number");
        return;
      }
      build_num = escape(msg.match[2]);
      return msg.http(endpoint + "/project/" + project + "/" + build_num + "/cancel?circle-token=" + process.env.HUBOT_CIRCLECI_TOKEN).headers({
        "Accept": "application/json"
      }).post('{}')(handleResponse(msg, function(response) {
        return msg.send("Canceled build " + response.build_num + " for " + project + " [" + response.branch + "]");
      }));
    });
    robot.respond(/circle clear (.*)/i, function(msg) {
      var project;
      if (!checkToken(msg)) {
        return;
      }
      if (msg.match[1] === 'all') {
        return clearAllProjectsCache(msg, endpoint);
      } else {
        project = escape(toProject(msg.match[1]));
        return clearProjectCache(msg, endpoint, project);
      }
    });
    return robot.router.post("/hubot/circle", function(req, res) {
      var error, error1, query, user;
      console.log("Received circle webhook callback");
      query = querystring.parse(url.parse(req.url).query);
      res.end(JSON.stringify({
        received: true
      }));
      user = robot.brain.userForId('broadcast');
      if (query.room) {
        user.room = query.room;
      }
      if (query.type) {
        user.type = query.type;
      }
      console.log("Received CircleCI payload: " + (util.inspect(req.body.payload)));
      try {
        robot.send(user, formatBuildStatus(req.body.payload));
        return console.log("Sent CircleCI build status message");
      } catch (error1) {
        error = error1;
        return console.log("circle hook error: " + error + ". Payload: " + (util.inspect(req.body.payload)));
      }
    });
  };

}).call(this);
